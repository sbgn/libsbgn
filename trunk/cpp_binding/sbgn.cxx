// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "sbgn.hxx"

namespace libsbgn
{
  namespace pd_0_1
  {
    // bbox
    // 

    const bbox::x_type& bbox::
    x () const
    {
      return this->x_.get ();
    }

    bbox::x_type& bbox::
    x ()
    {
      return this->x_.get ();
    }

    void bbox::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const bbox::y_type& bbox::
    y () const
    {
      return this->y_.get ();
    }

    bbox::y_type& bbox::
    y ()
    {
      return this->y_.get ();
    }

    void bbox::
    y (const y_type& x)
    {
      this->y_.set (x);
    }

    const bbox::w_type& bbox::
    w () const
    {
      return this->w_.get ();
    }

    bbox::w_type& bbox::
    w ()
    {
      return this->w_.get ();
    }

    void bbox::
    w (const w_type& x)
    {
      this->w_.set (x);
    }

    const bbox::h_type& bbox::
    h () const
    {
      return this->h_.get ();
    }

    bbox::h_type& bbox::
    h ()
    {
      return this->h_.get ();
    }

    void bbox::
    h (const h_type& x)
    {
      this->h_.set (x);
    }


    // map
    // 

    const map::glyph_sequence& map::
    glyph () const
    {
      return this->glyph_;
    }

    map::glyph_sequence& map::
    glyph ()
    {
      return this->glyph_;
    }

    void map::
    glyph (const glyph_sequence& s)
    {
      this->glyph_ = s;
    }

    const map::arc_sequence& map::
    arc () const
    {
      return this->arc_;
    }

    map::arc_sequence& map::
    arc ()
    {
      return this->arc_;
    }

    void map::
    arc (const arc_sequence& s)
    {
      this->arc_ = s;
    }


    // sbgn
    // 

    const sbgn::map_sequence& sbgn::
    map () const
    {
      return this->map_;
    }

    sbgn::map_sequence& sbgn::
    map ()
    {
      return this->map_;
    }

    void sbgn::
    map (const map_sequence& s)
    {
      this->map_ = s;
    }


    // glyph
    // 

    const glyph::label_optional& glyph::
    label () const
    {
      return this->label_;
    }

    glyph::label_optional& glyph::
    label ()
    {
      return this->label_;
    }

    void glyph::
    label (const label_type& x)
    {
      this->label_.set (x);
    }

    void glyph::
    label (const label_optional& x)
    {
      this->label_ = x;
    }

    void glyph::
    label (::std::auto_ptr< label_type > x)
    {
      this->label_.set (x);
    }

    const glyph::state_optional& glyph::
    state () const
    {
      return this->state_;
    }

    glyph::state_optional& glyph::
    state ()
    {
      return this->state_;
    }

    void glyph::
    state (const state_type& x)
    {
      this->state_.set (x);
    }

    void glyph::
    state (const state_optional& x)
    {
      this->state_ = x;
    }

    void glyph::
    state (::std::auto_ptr< state_type > x)
    {
      this->state_.set (x);
    }

    const glyph::clone_optional& glyph::
    clone () const
    {
      return this->clone_;
    }

    glyph::clone_optional& glyph::
    clone ()
    {
      return this->clone_;
    }

    void glyph::
    clone (const clone_type& x)
    {
      this->clone_.set (x);
    }

    void glyph::
    clone (const clone_optional& x)
    {
      this->clone_ = x;
    }

    void glyph::
    clone (::std::auto_ptr< clone_type > x)
    {
      this->clone_.set (x);
    }

    const glyph::bbox_type& glyph::
    bbox () const
    {
      return this->bbox_.get ();
    }

    glyph::bbox_type& glyph::
    bbox ()
    {
      return this->bbox_.get ();
    }

    void glyph::
    bbox (const bbox_type& x)
    {
      this->bbox_.set (x);
    }

    void glyph::
    bbox (::std::auto_ptr< bbox_type > x)
    {
      this->bbox_.set (x);
    }

    const glyph::glyph1_sequence& glyph::
    glyph1 () const
    {
      return this->glyph1_;
    }

    glyph::glyph1_sequence& glyph::
    glyph1 ()
    {
      return this->glyph1_;
    }

    void glyph::
    glyph1 (const glyph1_sequence& s)
    {
      this->glyph1_ = s;
    }

    const glyph::port_sequence& glyph::
    port () const
    {
      return this->port_;
    }

    glyph::port_sequence& glyph::
    port ()
    {
      return this->port_;
    }

    void glyph::
    port (const port_sequence& s)
    {
      this->port_ = s;
    }

    const glyph::class_type& glyph::
    class_ () const
    {
      return this->class__.get ();
    }

    glyph::class_type& glyph::
    class_ ()
    {
      return this->class__.get ();
    }

    void glyph::
    class_ (const class_type& x)
    {
      this->class__.set (x);
    }

    void glyph::
    class_ (::std::auto_ptr< class_type > x)
    {
      this->class__.set (x);
    }

    const glyph::class_type& glyph::
    class_default_value ()
    {
      return class__default_value_;
    }

    const glyph::orientation_type& glyph::
    orientation () const
    {
      return this->orientation_.get ();
    }

    glyph::orientation_type& glyph::
    orientation ()
    {
      return this->orientation_.get ();
    }

    void glyph::
    orientation (const orientation_type& x)
    {
      this->orientation_.set (x);
    }

    void glyph::
    orientation (::std::auto_ptr< orientation_type > x)
    {
      this->orientation_.set (x);
    }

    const glyph::orientation_type& glyph::
    orientation_default_value ()
    {
      return orientation_default_value_;
    }

    const glyph::id_type& glyph::
    id () const
    {
      return this->id_.get ();
    }

    glyph::id_type& glyph::
    id ()
    {
      return this->id_.get ();
    }

    void glyph::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void glyph::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // arc
    // 

    const arc::glyph_optional& arc::
    glyph () const
    {
      return this->glyph_;
    }

    arc::glyph_optional& arc::
    glyph ()
    {
      return this->glyph_;
    }

    void arc::
    glyph (const glyph_type& x)
    {
      this->glyph_.set (x);
    }

    void arc::
    glyph (const glyph_optional& x)
    {
      this->glyph_ = x;
    }

    void arc::
    glyph (::std::auto_ptr< glyph_type > x)
    {
      this->glyph_.set (x);
    }

    const arc::start_type& arc::
    start () const
    {
      return this->start_.get ();
    }

    arc::start_type& arc::
    start ()
    {
      return this->start_.get ();
    }

    void arc::
    start (const start_type& x)
    {
      this->start_.set (x);
    }

    void arc::
    start (::std::auto_ptr< start_type > x)
    {
      this->start_.set (x);
    }

    const arc::next_sequence& arc::
    next () const
    {
      return this->next_;
    }

    arc::next_sequence& arc::
    next ()
    {
      return this->next_;
    }

    void arc::
    next (const next_sequence& s)
    {
      this->next_ = s;
    }

    const arc::end_type& arc::
    end () const
    {
      return this->end_.get ();
    }

    arc::end_type& arc::
    end ()
    {
      return this->end_.get ();
    }

    void arc::
    end (const end_type& x)
    {
      this->end_.set (x);
    }

    void arc::
    end (::std::auto_ptr< end_type > x)
    {
      this->end_.set (x);
    }

    const arc::class_optional& arc::
    class_ () const
    {
      return this->class__;
    }

    arc::class_optional& arc::
    class_ ()
    {
      return this->class__;
    }

    void arc::
    class_ (const class_type& x)
    {
      this->class__.set (x);
    }

    void arc::
    class_ (const class_optional& x)
    {
      this->class__ = x;
    }

    void arc::
    class_ (::std::auto_ptr< class_type > x)
    {
      this->class__.set (x);
    }

    const arc::source_type& arc::
    source () const
    {
      return this->source_.get ();
    }

    arc::source_type& arc::
    source ()
    {
      return this->source_.get ();
    }

    void arc::
    source (const source_type& x)
    {
      this->source_.set (x);
    }

    void arc::
    source (::std::auto_ptr< source_type > x)
    {
      this->source_.set (x);
    }

    const arc::target_type& arc::
    target () const
    {
      return this->target_.get ();
    }

    arc::target_type& arc::
    target ()
    {
      return this->target_.get ();
    }

    void arc::
    target (const target_type& x)
    {
      this->target_.set (x);
    }

    void arc::
    target (::std::auto_ptr< target_type > x)
    {
      this->target_.set (x);
    }


    // point
    // 

    const point::x_type& point::
    x () const
    {
      return this->x_.get ();
    }

    point::x_type& point::
    x ()
    {
      return this->x_.get ();
    }

    void point::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const point::y_type& point::
    y () const
    {
      return this->y_.get ();
    }

    point::y_type& point::
    y ()
    {
      return this->y_.get ();
    }

    void point::
    y (const y_type& x)
    {
      this->y_.set (x);
    }


    // label
    // 

    const label::bbox_optional& label::
    bbox () const
    {
      return this->bbox_;
    }

    label::bbox_optional& label::
    bbox ()
    {
      return this->bbox_;
    }

    void label::
    bbox (const bbox_type& x)
    {
      this->bbox_.set (x);
    }

    void label::
    bbox (const bbox_optional& x)
    {
      this->bbox_ = x;
    }

    void label::
    bbox (::std::auto_ptr< bbox_type > x)
    {
      this->bbox_.set (x);
    }

    const label::text_type& label::
    text () const
    {
      return this->text_.get ();
    }

    label::text_type& label::
    text ()
    {
      return this->text_.get ();
    }

    void label::
    text (const text_type& x)
    {
      this->text_.set (x);
    }

    void label::
    text (::std::auto_ptr< text_type > x)
    {
      this->text_.set (x);
    }

    const label::font_optional& label::
    font () const
    {
      return this->font_;
    }

    label::font_optional& label::
    font ()
    {
      return this->font_;
    }

    void label::
    font (const font_type& x)
    {
      this->font_.set (x);
    }

    void label::
    font (const font_optional& x)
    {
      this->font_ = x;
    }

    void label::
    font (::std::auto_ptr< font_type > x)
    {
      this->font_.set (x);
    }

    const label::fontsize_optional& label::
    fontsize () const
    {
      return this->fontsize_;
    }

    label::fontsize_optional& label::
    fontsize ()
    {
      return this->fontsize_;
    }

    void label::
    fontsize (const fontsize_type& x)
    {
      this->fontsize_.set (x);
    }

    void label::
    fontsize (const fontsize_optional& x)
    {
      this->fontsize_ = x;
    }


    // state
    // 

    const state::value_type& state::
    value () const
    {
      return this->value_.get ();
    }

    state::value_type& state::
    value ()
    {
      return this->value_.get ();
    }

    void state::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void state::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }

    const state::variable_optional& state::
    variable () const
    {
      return this->variable_;
    }

    state::variable_optional& state::
    variable ()
    {
      return this->variable_;
    }

    void state::
    variable (const variable_type& x)
    {
      this->variable_.set (x);
    }

    void state::
    variable (const variable_optional& x)
    {
      this->variable_ = x;
    }

    void state::
    variable (::std::auto_ptr< variable_type > x)
    {
      this->variable_.set (x);
    }


    // clone
    // 

    const clone::label_optional& clone::
    label () const
    {
      return this->label_;
    }

    clone::label_optional& clone::
    label ()
    {
      return this->label_;
    }

    void clone::
    label (const label_type& x)
    {
      this->label_.set (x);
    }

    void clone::
    label (const label_optional& x)
    {
      this->label_ = x;
    }

    void clone::
    label (::std::auto_ptr< label_type > x)
    {
      this->label_.set (x);
    }


    // port
    // 

    const port::x_type& port::
    x () const
    {
      return this->x_.get ();
    }

    port::x_type& port::
    x ()
    {
      return this->x_.get ();
    }

    void port::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const port::y_type& port::
    y () const
    {
      return this->y_.get ();
    }

    port::y_type& port::
    y ()
    {
      return this->y_.get ();
    }

    void port::
    y (const y_type& x)
    {
      this->y_.set (x);
    }

    const port::id_type& port::
    id () const
    {
      return this->id_.get ();
    }

    port::id_type& port::
    id ()
    {
      return this->id_.get ();
    }

    void port::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void port::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // class_
    // 

    class_::
    class_ (value v)
    : ::xml_schema::string (_xsd_class__literals_[v])
    {
    }

    class_::
    class_ (const char* v)
    : ::xml_schema::string (v)
    {
    }

    class_::
    class_ (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    class_::
    class_ (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    class_::
    class_ (const class_& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    class_& class_::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_class__literals_[v]);

      return *this;
    }


    // orientation
    // 

    orientation::
    orientation (value v)
    : ::xml_schema::string (_xsd_orientation_literals_[v])
    {
    }

    orientation::
    orientation (const char* v)
    : ::xml_schema::string (v)
    {
    }

    orientation::
    orientation (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    orientation::
    orientation (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    orientation::
    orientation (const orientation& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    orientation& orientation::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_orientation_literals_[v]);

      return *this;
    }


    // start
    // 

    const start::x_type& start::
    x () const
    {
      return this->x_.get ();
    }

    start::x_type& start::
    x ()
    {
      return this->x_.get ();
    }

    void start::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const start::y_type& start::
    y () const
    {
      return this->y_.get ();
    }

    start::y_type& start::
    y ()
    {
      return this->y_.get ();
    }

    void start::
    y (const y_type& x)
    {
      this->y_.set (x);
    }


    // next
    // 

    const next::point_sequence& next::
    point () const
    {
      return this->point_;
    }

    next::point_sequence& next::
    point ()
    {
      return this->point_;
    }

    void next::
    point (const point_sequence& s)
    {
      this->point_ = s;
    }

    const next::x_type& next::
    x () const
    {
      return this->x_.get ();
    }

    next::x_type& next::
    x ()
    {
      return this->x_.get ();
    }

    void next::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const next::y_type& next::
    y () const
    {
      return this->y_.get ();
    }

    next::y_type& next::
    y ()
    {
      return this->y_.get ();
    }

    void next::
    y (const y_type& x)
    {
      this->y_.set (x);
    }


    // end
    // 

    const end::point_sequence& end::
    point () const
    {
      return this->point_;
    }

    end::point_sequence& end::
    point ()
    {
      return this->point_;
    }

    void end::
    point (const point_sequence& s)
    {
      this->point_ = s;
    }

    const end::x_type& end::
    x () const
    {
      return this->x_.get ();
    }

    end::x_type& end::
    x ()
    {
      return this->x_.get ();
    }

    void end::
    x (const x_type& x)
    {
      this->x_.set (x);
    }

    const end::y_type& end::
    y () const
    {
      return this->y_.get ();
    }

    end::y_type& end::
    y ()
    {
      return this->y_.get ();
    }

    void end::
    y (const y_type& x)
    {
      this->y_.set (x);
    }


    // class1
    // 

    class1::
    class1 (value v)
    : ::xml_schema::string (_xsd_class1_literals_[v])
    {
    }

    class1::
    class1 (const char* v)
    : ::xml_schema::string (v)
    {
    }

    class1::
    class1 (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    class1::
    class1 (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    class1::
    class1 (const class1& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    class1& class1::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_class1_literals_[v]);

      return *this;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace libsbgn
{
  namespace pd_0_1
  {
    // bbox
    //

    bbox::
    bbox (const x_type& x,
          const y_type& y,
          const w_type& w,
          const h_type& h)
    : ::xml_schema::type (),
      x_ (x, ::xml_schema::flags (), this),
      y_ (y, ::xml_schema::flags (), this),
      w_ (w, ::xml_schema::flags (), this),
      h_ (h, ::xml_schema::flags (), this)
    {
    }

    bbox::
    bbox (const bbox& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      w_ (x.w_, f, this),
      h_ (x.h_, f, this)
    {
    }

    bbox::
    bbox (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      x_ (f, this),
      y_ (f, this),
      w_ (f, this),
      h_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void bbox::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "w" && n.namespace_ ().empty ())
        {
          this->w_.set (w_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "h" && n.namespace_ ().empty ())
        {
          this->h_.set (h_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }

      if (!w_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "w",
          "");
      }

      if (!h_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "h",
          "");
      }
    }

    bbox* bbox::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class bbox (*this, f, c);
    }

    bbox::
    ~bbox ()
    {
    }

    // map
    //

    map::
    map ()
    : ::xml_schema::type (),
      glyph_ (::xml_schema::flags (), this),
      arc_ (::xml_schema::flags (), this)
    {
    }

    map::
    map (const map& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      glyph_ (x.glyph_, f, this),
      arc_ (x.arc_, f, this)
    {
    }

    map::
    map (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      glyph_ (f, this),
      arc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void map::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // glyph
        //
        if (n.name () == "glyph" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< glyph_type > r (
            glyph_traits::create (i, f, this));

          this->glyph_.push_back (r);
          continue;
        }

        // arc
        //
        if (n.name () == "arc" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< arc_type > r (
            arc_traits::create (i, f, this));

          this->arc_.push_back (r);
          continue;
        }

        break;
      }
    }

    map* map::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class map (*this, f, c);
    }

    map::
    ~map ()
    {
    }

    // sbgn
    //

    sbgn::
    sbgn ()
    : ::xml_schema::type (),
      map_ (::xml_schema::flags (), this)
    {
    }

    sbgn::
    sbgn (const sbgn& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      map_ (x.map_, f, this)
    {
    }

    sbgn::
    sbgn (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      map_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void sbgn::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // map
        //
        if (n.name () == "map" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< map_type > r (
            map_traits::create (i, f, this));

          this->map_.push_back (r);
          continue;
        }

        break;
      }
    }

    sbgn* sbgn::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class sbgn (*this, f, c);
    }

    sbgn::
    ~sbgn ()
    {
    }

    // glyph
    //

    const glyph::class_type glyph::class__default_value_ (
      "unspecified entity");

    const glyph::orientation_type glyph::orientation_default_value_ (
      "horizontal");

    glyph::
    glyph (const bbox_type& bbox,
           const id_type& id)
    : ::xml_schema::type (),
      label_ (::xml_schema::flags (), this),
      state_ (::xml_schema::flags (), this),
      clone_ (::xml_schema::flags (), this),
      bbox_ (bbox, ::xml_schema::flags (), this),
      glyph1_ (::xml_schema::flags (), this),
      port_ (::xml_schema::flags (), this),
      class__ (class_default_value (), ::xml_schema::flags (), this),
      orientation_ (orientation_default_value (), ::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    glyph::
    glyph (::std::auto_ptr< bbox_type >& bbox,
           const id_type& id)
    : ::xml_schema::type (),
      label_ (::xml_schema::flags (), this),
      state_ (::xml_schema::flags (), this),
      clone_ (::xml_schema::flags (), this),
      bbox_ (bbox, ::xml_schema::flags (), this),
      glyph1_ (::xml_schema::flags (), this),
      port_ (::xml_schema::flags (), this),
      class__ (class_default_value (), ::xml_schema::flags (), this),
      orientation_ (orientation_default_value (), ::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    glyph::
    glyph (const glyph& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      label_ (x.label_, f, this),
      state_ (x.state_, f, this),
      clone_ (x.clone_, f, this),
      bbox_ (x.bbox_, f, this),
      glyph1_ (x.glyph1_, f, this),
      port_ (x.port_, f, this),
      class__ (x.class__, f, this),
      orientation_ (x.orientation_, f, this),
      id_ (x.id_, f, this)
    {
    }

    glyph::
    glyph (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      label_ (f, this),
      state_ (f, this),
      clone_ (f, this),
      bbox_ (f, this),
      glyph1_ (f, this),
      port_ (f, this),
      class__ (f, this),
      orientation_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void glyph::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // label
        //
        if (n.name () == "label" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< label_type > r (
            label_traits::create (i, f, this));

          if (!this->label_)
          {
            this->label_.set (r);
            continue;
          }
        }

        // state
        //
        if (n.name () == "state" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< state_type > r (
            state_traits::create (i, f, this));

          if (!this->state_)
          {
            this->state_.set (r);
            continue;
          }
        }

        // clone
        //
        if (n.name () == "clone" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< clone_type > r (
            clone_traits::create (i, f, this));

          if (!this->clone_)
          {
            this->clone_.set (r);
            continue;
          }
        }

        // bbox
        //
        if (n.name () == "bbox" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< bbox_type > r (
            bbox_traits::create (i, f, this));

          if (!bbox_.present ())
          {
            this->bbox_.set (r);
            continue;
          }
        }

        // glyph
        //
        if (n.name () == "glyph" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< glyph1_type > r (
            glyph1_traits::create (i, f, this));

          this->glyph1_.push_back (r);
          continue;
        }

        // port
        //
        if (n.name () == "port" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< port_type > r (
            port_traits::create (i, f, this));

          this->port_.push_back (r);
          continue;
        }

        break;
      }

      if (!bbox_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "bbox",
          "http://sbgn.org/libsbgn/pd/0.1");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "class" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< class_type > r (
            class_traits::create (i, f, this));

          this->class__.set (r);
          continue;
        }

        if (n.name () == "orientation" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< orientation_type > r (
            orientation_traits::create (i, f, this));

          this->orientation_.set (r);
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!class__.present ())
      {
        this->class__.set (class_default_value ());
      }

      if (!orientation_.present ())
      {
        this->orientation_.set (orientation_default_value ());
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    glyph* glyph::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class glyph (*this, f, c);
    }

    glyph::
    ~glyph ()
    {
    }

    // arc
    //

    arc::
    arc (const start_type& start,
         const end_type& end,
         const source_type& source,
         const target_type& target)
    : ::xml_schema::type (),
      glyph_ (::xml_schema::flags (), this),
      start_ (start, ::xml_schema::flags (), this),
      next_ (::xml_schema::flags (), this),
      end_ (end, ::xml_schema::flags (), this),
      class__ (::xml_schema::flags (), this),
      source_ (source, ::xml_schema::flags (), this),
      target_ (target, ::xml_schema::flags (), this)
    {
    }

    arc::
    arc (::std::auto_ptr< start_type >& start,
         ::std::auto_ptr< end_type >& end,
         const source_type& source,
         const target_type& target)
    : ::xml_schema::type (),
      glyph_ (::xml_schema::flags (), this),
      start_ (start, ::xml_schema::flags (), this),
      next_ (::xml_schema::flags (), this),
      end_ (end, ::xml_schema::flags (), this),
      class__ (::xml_schema::flags (), this),
      source_ (source, ::xml_schema::flags (), this),
      target_ (target, ::xml_schema::flags (), this)
    {
    }

    arc::
    arc (const arc& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      glyph_ (x.glyph_, f, this),
      start_ (x.start_, f, this),
      next_ (x.next_, f, this),
      end_ (x.end_, f, this),
      class__ (x.class__, f, this),
      source_ (x.source_, f, this),
      target_ (x.target_, f, this)
    {
    }

    arc::
    arc (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      glyph_ (f, this),
      start_ (f, this),
      next_ (f, this),
      end_ (f, this),
      class__ (f, this),
      source_ (f, this),
      target_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void arc::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // glyph
        //
        if (n.name () == "glyph" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< glyph_type > r (
            glyph_traits::create (i, f, this));

          if (!this->glyph_)
          {
            this->glyph_.set (r);
            continue;
          }
        }

        // start
        //
        if (n.name () == "start" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< start_type > r (
            start_traits::create (i, f, this));

          if (!start_.present ())
          {
            this->start_.set (r);
            continue;
          }
        }

        // next
        //
        if (n.name () == "next" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< next_type > r (
            next_traits::create (i, f, this));

          this->next_.push_back (r);
          continue;
        }

        // end
        //
        if (n.name () == "end" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< end_type > r (
            end_traits::create (i, f, this));

          if (!end_.present ())
          {
            this->end_.set (r);
            continue;
          }
        }

        break;
      }

      if (!start_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "start",
          "http://sbgn.org/libsbgn/pd/0.1");
      }

      if (!end_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "end",
          "http://sbgn.org/libsbgn/pd/0.1");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "class" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< class_type > r (
            class_traits::create (i, f, this));

          this->class__.set (r);
          continue;
        }

        if (n.name () == "source" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< source_type > r (
            source_traits::create (i, f, this));

          this->source_.set (r);
          continue;
        }

        if (n.name () == "target" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< target_type > r (
            target_traits::create (i, f, this));

          this->target_.set (r);
          continue;
        }
      }

      if (!source_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "source",
          "");
      }

      if (!target_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "target",
          "");
      }
    }

    arc* arc::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class arc (*this, f, c);
    }

    arc::
    ~arc ()
    {
    }

    // point
    //

    point::
    point (const x_type& x,
           const y_type& y)
    : ::xml_schema::type (),
      x_ (x, ::xml_schema::flags (), this),
      y_ (y, ::xml_schema::flags (), this)
    {
    }

    point::
    point (const point& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this)
    {
    }

    point::
    point (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      x_ (f, this),
      y_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void point::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }
    }

    point* point::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class point (*this, f, c);
    }

    point::
    ~point ()
    {
    }

    // label
    //

    label::
    label (const text_type& text)
    : ::xml_schema::type (),
      bbox_ (::xml_schema::flags (), this),
      text_ (text, ::xml_schema::flags (), this),
      font_ (::xml_schema::flags (), this),
      fontsize_ (::xml_schema::flags (), this)
    {
    }

    label::
    label (const label& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      bbox_ (x.bbox_, f, this),
      text_ (x.text_, f, this),
      font_ (x.font_, f, this),
      fontsize_ (x.fontsize_, f, this)
    {
    }

    label::
    label (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      bbox_ (f, this),
      text_ (f, this),
      font_ (f, this),
      fontsize_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void label::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // bbox
        //
        if (n.name () == "bbox" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< bbox_type > r (
            bbox_traits::create (i, f, this));

          if (!this->bbox_)
          {
            this->bbox_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "text" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< text_type > r (
            text_traits::create (i, f, this));

          this->text_.set (r);
          continue;
        }

        if (n.name () == "font" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< font_type > r (
            font_traits::create (i, f, this));

          this->font_.set (r);
          continue;
        }

        if (n.name () == "fontsize" && n.namespace_ ().empty ())
        {
          this->fontsize_.set (fontsize_traits::create (i, f, this));
          continue;
        }
      }

      if (!text_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "text",
          "");
      }
    }

    label* label::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class label (*this, f, c);
    }

    label::
    ~label ()
    {
    }

    // state
    //

    state::
    state (const value_type& value)
    : ::xml_schema::type (),
      value_ (value, ::xml_schema::flags (), this),
      variable_ (::xml_schema::flags (), this)
    {
    }

    state::
    state (const state& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      value_ (x.value_, f, this),
      variable_ (x.variable_, f, this)
    {
    }

    state::
    state (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      value_ (f, this),
      variable_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void state::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< value_type > r (
            value_traits::create (i, f, this));

          this->value_.set (r);
          continue;
        }

        if (n.name () == "variable" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< variable_type > r (
            variable_traits::create (i, f, this));

          this->variable_.set (r);
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    state* state::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class state (*this, f, c);
    }

    state::
    ~state ()
    {
    }

    // clone
    //

    clone::
    clone ()
    : ::xml_schema::type (),
      label_ (::xml_schema::flags (), this)
    {
    }

    clone::
    clone (const clone& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      label_ (x.label_, f, this)
    {
    }

    clone::
    clone (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      label_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void clone::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // label
        //
        if (n.name () == "label" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< label_type > r (
            label_traits::create (i, f, this));

          if (!this->label_)
          {
            this->label_.set (r);
            continue;
          }
        }

        break;
      }
    }

    clone* clone::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class clone (*this, f, c);
    }

    clone::
    ~clone ()
    {
    }

    // port
    //

    port::
    port (const x_type& x,
          const y_type& y,
          const id_type& id)
    : ::xml_schema::type (),
      x_ (x, ::xml_schema::flags (), this),
      y_ (y, ::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    port::
    port (const port& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      id_ (x.id_, f, this)
    {
    }

    port::
    port (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      x_ (f, this),
      y_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void port::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    port* port::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class port (*this, f, c);
    }

    port::
    ~port ()
    {
    }

    // class_
    //

    class_::
    class_ (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_class__convert ();
    }

    class_::
    class_ (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_class__convert ();
    }

    class_::
    class_ (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_class__convert ();
    }

    class_* class_::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class class_ (*this, f, c);
    }

    class_::value class_::
    _xsd_class__convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_class__literals_);
      const value* i (::std::lower_bound (
                        _xsd_class__indexes_,
                        _xsd_class__indexes_ + 26,
                        *this,
                        c));

      if (i == _xsd_class__indexes_ + 26 || _xsd_class__literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const class_::
    _xsd_class__literals_[26] =
    {
      "unspecified entity",
      "simple chemical",
      "macromolecule",
      "nucleic acid feature",
      "simple chemical multimer",
      "macromolecule multimer",
      "nucleic acid feature multimer",
      "complex",
      "complex multimer",
      "source and sink",
      "perturbing agent",
      "compartment",
      "submap",
      "tag",
      "process",
      "omitted process",
      "uncertain process",
      "association",
      "dissociation",
      "phenotype",
      "and",
      "or",
      "not",
      "state variable",
      "unit of information",
      "stoichiometry"
    };

    const class_::value class_::
    _xsd_class__indexes_[26] =
    {
      ::libsbgn::pd_0_1::class_::and_,
      ::libsbgn::pd_0_1::class_::association,
      ::libsbgn::pd_0_1::class_::compartment,
      ::libsbgn::pd_0_1::class_::complex,
      ::libsbgn::pd_0_1::class_::complex_multimer,
      ::libsbgn::pd_0_1::class_::dissociation,
      ::libsbgn::pd_0_1::class_::macromolecule,
      ::libsbgn::pd_0_1::class_::macromolecule_multimer,
      ::libsbgn::pd_0_1::class_::not_,
      ::libsbgn::pd_0_1::class_::nucleic_acid_feature,
      ::libsbgn::pd_0_1::class_::nucleic_acid_feature_multimer,
      ::libsbgn::pd_0_1::class_::omitted_process,
      ::libsbgn::pd_0_1::class_::or_,
      ::libsbgn::pd_0_1::class_::perturbing_agent,
      ::libsbgn::pd_0_1::class_::phenotype,
      ::libsbgn::pd_0_1::class_::process,
      ::libsbgn::pd_0_1::class_::simple_chemical,
      ::libsbgn::pd_0_1::class_::simple_chemical_multimer,
      ::libsbgn::pd_0_1::class_::source_and_sink,
      ::libsbgn::pd_0_1::class_::state_variable,
      ::libsbgn::pd_0_1::class_::stoichiometry,
      ::libsbgn::pd_0_1::class_::submap,
      ::libsbgn::pd_0_1::class_::tag,
      ::libsbgn::pd_0_1::class_::uncertain_process,
      ::libsbgn::pd_0_1::class_::unit_of_information,
      ::libsbgn::pd_0_1::class_::unspecified_entity
    };

    // orientation
    //

    orientation::
    orientation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_orientation_convert ();
    }

    orientation::
    orientation (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_orientation_convert ();
    }

    orientation::
    orientation (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_orientation_convert ();
    }

    orientation* orientation::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class orientation (*this, f, c);
    }

    orientation::value orientation::
    _xsd_orientation_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_orientation_literals_);
      const value* i (::std::lower_bound (
                        _xsd_orientation_indexes_,
                        _xsd_orientation_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_orientation_indexes_ + 6 || _xsd_orientation_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const orientation::
    _xsd_orientation_literals_[6] =
    {
      "horizontal",
      "vertical",
      "left",
      "right",
      "up",
      "down"
    };

    const orientation::value orientation::
    _xsd_orientation_indexes_[6] =
    {
      ::libsbgn::pd_0_1::orientation::down,
      ::libsbgn::pd_0_1::orientation::horizontal,
      ::libsbgn::pd_0_1::orientation::left,
      ::libsbgn::pd_0_1::orientation::right,
      ::libsbgn::pd_0_1::orientation::up,
      ::libsbgn::pd_0_1::orientation::vertical
    };

    // start
    //

    start::
    start (const x_type& x,
           const y_type& y)
    : ::xml_schema::type (),
      x_ (x, ::xml_schema::flags (), this),
      y_ (y, ::xml_schema::flags (), this)
    {
    }

    start::
    start (const start& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this)
    {
    }

    start::
    start (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      x_ (f, this),
      y_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void start::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }
    }

    start* start::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class start (*this, f, c);
    }

    start::
    ~start ()
    {
    }

    // next
    //

    next::
    next (const x_type& x,
          const y_type& y)
    : ::xml_schema::type (),
      point_ (::xml_schema::flags (), this),
      x_ (x, ::xml_schema::flags (), this),
      y_ (y, ::xml_schema::flags (), this)
    {
    }

    next::
    next (const next& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      point_ (x.point_, f, this),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this)
    {
    }

    next::
    next (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      point_ (f, this),
      x_ (f, this),
      y_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void next::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // point
        //
        if (n.name () == "point" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< point_type > r (
            point_traits::create (i, f, this));

          this->point_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }
    }

    next* next::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class next (*this, f, c);
    }

    next::
    ~next ()
    {
    }

    // end
    //

    end::
    end (const x_type& x,
         const y_type& y)
    : ::xml_schema::type (),
      point_ (::xml_schema::flags (), this),
      x_ (x, ::xml_schema::flags (), this),
      y_ (y, ::xml_schema::flags (), this)
    {
    }

    end::
    end (const end& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      point_ (x.point_, f, this),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this)
    {
    }

    end::
    end (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      point_ (f, this),
      x_ (f, this),
      y_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void end::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // point
        //
        if (n.name () == "point" && n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
        {
          ::std::auto_ptr< point_type > r (
            point_traits::create (i, f, this));

          this->point_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }
    }

    end* end::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class end (*this, f, c);
    }

    end::
    ~end ()
    {
    }

    // class1
    //

    class1::
    class1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_class1_convert ();
    }

    class1::
    class1 (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_class1_convert ();
    }

    class1::
    class1 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_class1_convert ();
    }

    class1* class1::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class class1 (*this, f, c);
    }

    class1::value class1::
    _xsd_class1_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_class1_literals_);
      const value* i (::std::lower_bound (
                        _xsd_class1_indexes_,
                        _xsd_class1_indexes_ + 9,
                        *this,
                        c));

      if (i == _xsd_class1_indexes_ + 9 || _xsd_class1_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const class1::
    _xsd_class1_literals_[9] =
    {
      "production",
      "consumption",
      "modulation",
      "stimulation",
      "catalysis",
      "inhibition",
      "necessary stimulation",
      "logic arc",
      "equivalence arc"
    };

    const class1::value class1::
    _xsd_class1_indexes_[9] =
    {
      ::libsbgn::pd_0_1::class1::catalysis,
      ::libsbgn::pd_0_1::class1::consumption,
      ::libsbgn::pd_0_1::class1::equivalence_arc,
      ::libsbgn::pd_0_1::class1::inhibition,
      ::libsbgn::pd_0_1::class1::logic_arc,
      ::libsbgn::pd_0_1::class1::modulation,
      ::libsbgn::pd_0_1::class1::necessary_stimulation,
      ::libsbgn::pd_0_1::class1::production,
      ::libsbgn::pd_0_1::class1::stimulation
    };
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace libsbgn
{
  namespace pd_0_1
  {
    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
        ::libsbgn::pd_0_1::sbgn_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
        ::libsbgn::pd_0_1::sbgn_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
        ::libsbgn::pd_0_1::sbgn_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::libsbgn::pd_0_1::sbgn_ (isrc, f, p);
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::libsbgn::pd_0_1::sbgn_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::libsbgn::pd_0_1::sbgn_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::libsbgn::pd_0_1::sbgn_ (isrc, f, p);
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::libsbgn::pd_0_1::sbgn_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::libsbgn::pd_0_1::sbgn_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
        ::libsbgn::pd_0_1::sbgn_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
        ::libsbgn::pd_0_1::sbgn_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
        ::libsbgn::pd_0_1::sbgn_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
          ::libsbgn::pd_0_1::sbgn_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "sbgn" &&
          n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
      {
        ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
          ::xsd::cxx::tree::traits< ::libsbgn::pd_0_1::sbgn, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "sbgn",
        "http://sbgn.org/libsbgn/pd/0.1");
    }

    ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn >
    sbgn_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "sbgn" &&
          n.namespace_ () == "http://sbgn.org/libsbgn/pd/0.1")
      {
        ::std::auto_ptr< ::libsbgn::pd_0_1::sbgn > r (
          ::xsd::cxx::tree::traits< ::libsbgn::pd_0_1::sbgn, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "sbgn",
        "http://sbgn.org/libsbgn/pd/0.1");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

